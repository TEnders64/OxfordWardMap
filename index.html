<!DOCTYPE html>
<html>
	<head>
	<meta charset="utf-8">
	<title>Testing out D3</title>
	<script src="https://cdnjs.cloudflare.com/ajax/libs/d3/3.5.5/d3.min.js" charset="utf-8"></script>
	<script src="http://d3js.org/topojson.v1.min.js"></script>
	<script src="ColorBrewer.js"></script>
	<script src="d3-tool.js"></script>
	<script src="https://ajax.googleapis.com/ajax/libs/jquery/1.11.3/jquery.min.js"></script>
	<link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.5/css/bootstrap.min.css">
	<script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.5/js/bootstrap.min.js"></script>	
	<style>
	
		.jumbotron h1 {
			font-size: 18px;
			font-weight: bold;
			font-family: "Arial Narrow";
			color: green
		}
			
		.jumbotron p  {
			font-size: 14px;
			font-weight: italic;
			font-family: "Calibri";
			color: blue
		}
			
		.active {
			opacity:0.9
		}
		
		#bar {
			padding-left: 5px;
			padding-right: 5px;
		}
		
		#bar svg {
			width:auto
		}
		
		.axis path,
		.axis line {
			fill: none;
			stroke: black;
			shape-rendering: crispEdges;
		}
		
		.axis text {
			font-family: sans-serif;
			font-size: 11px;
		}
		
		text {
			fill: black;
			font-weight: bold;
			font-family: arial;			
		}
		
		.wards path:hover {
			opacity:0.9;
		}
		
		<!--d3noob's tooltips page
		div.tooltip {
			position: absolute;
			visibility: visible;
			text-align: left;
			width: 60px;
			height: 30px;
			padding: 2px;
			background: #E6E6E6;
			border: 1px;
			border-radius: 2px;
			pointer-events: none;
		}-->
		
		.d3-tip {
			background: #CAEBFB;
			font-size: 10px;
			font-weight: bold;
			font-family: sans-serif;
			width: 200px;
			height: 50px;
			opacity: 0.5;
			padding: 4px;
			border: 1px;
			border-radius: 4px;
			pointer-events: none;
		}
		
		span {
			text-align:center;
			font-size: 11px;
		}
		
	</style>
	</head>
	<body>
		<div class="jumbotron">
			<div class="container">
				<h1>Oxford Relative/Surface Temperatures Based On Landsat-8 Imagery</h1>
				<p>The following maps and graphs outline the surface temperatures and relative surface temperatures of the wards of Oxford inside the Ring Road.
				Images from Landsat-8 have been available since 2013, thanks to NASA and the USGS.  The satellite takes images of Oxford every
				16 days. With that, there are 22 images a year, and furthermore, only a handful have completely clear conditions (non-cloudy) over Oxford.  
				The images are then inspected for cloud cover using Quantum GIS, where their data is then extracted and surface temperature calculations are 
				made based on Landsat-8's thermal infra-red sensor (Bands 10 and 11).  A relative comparison of surface temperatures is presented to display 
				the warmer wards of Oxford.</p>
			</div>
		</div>
		<div class="container">
			<div class="row">
				<div id="target" class="well well-lg col-md-6">
				</div>
				<div class="col-md-6">
					<div class="short-div">
						<div class="panel panel-info">
							<div class="panel-heading">View Data From Other Dates:</div>
							<div id="dates" class="panel-body"></div>
						</div>
					</div>
					<div class="short-div">
						<div class="panel panel-success">
							<div class="panel-heading">Urban Temp Comparison (based upon (&deg;C) warmer than coolest temp in Oxford)</div>
							<div id="bar" class="panel-body"></div>
						</div>
					</div>
				</div>
			</div>
		</div>
	<script type="text/javascript">
		
			var width = 537;
			var height = 500;
			var margin = {top: 15,
						  right: 20,
						  bottom: 20,
						  left: 40};
			var widthbar = 533 - margin.left - margin.right;
			var heightbar = 350 - margin.top - margin.bottom;
			var barpad = 1;
			var centered;
			var padding = 25;
			
			//Justin Palmer (labratrevenge.com) d3 tool tip add-on
			var tip = d3.tip()
						.attr("class","d3-tip")
						.html(function(d){return d;});
			
			//formatting numbers for display on tooltip
			var surfTemp = d3.format(".4g");
			var urbanTemp = d3.format(".3g");
			
			//initialising the color scale by using the d3 quantize() method on the range set by
			//the colorbrewer YlOrRd scale and 9 values (or shades)
			var color = d3.scale
						  .quantize()
						  .range(colorbrewer.YlOrRd[9]);
			
			//setting a projection around the Oxford area using lon and lat array.
			//notice scale is huge (190000)
			//using mercator projection as well
			var projection = d3.geo.mercator()
							.center([-1.2375, 51.7551])
							.scale(190000)
							.translate([width/2, height/2]);
							
			var path = d3.geo.path()
						.projection(projection);

			var svgmap = d3.select("#target").append("svg")
						.attr("width", width)
						.attr("height", height)
						.call(tip);
			
			var svgbar = d3.select("#bar").append("svg")
						.attr("width", widthbar + margin.left + margin.right)
						.attr("height", heightbar + margin.bottom + margin.top)
						.append("g")
						.attr("transform", "translate("+margin.left+","+margin.top+")")
						.call(tip);
						
			var g = svgmap.append("g");
						
			//declaring a div to the body for the tooltips
			//var divtool = d3.select("body")
			//			.append("div")
			//			.attr("class","tooltip")
			//			.style("opacity",0);
						
			// load and display the Oxford Roads, then Buildings, then Wards (SVG Ordering)
			// nesting is necessary for the roads, then buildings, then wards polygons to show up consecutively
			d3.json("OX_roads.geojson", function(error, OXroads) {
				if(error){console.log(error);}
				
				//not all roads are necessary...leaving only major roads determined by data in
				//GeoJSON file
				var majorRoads = [];
				for (var i=0;i<OXroads.features.length;i++){
					var roadType = OXroads.features[i].properties.FEATCODE;
					if (roadType === 25735 || roadType === 25729) {
						majorRoads.push(OXroads.features[i].geometry);
					}
				}				
				
				g.append("g")
				.attr("class","roads")
				.selectAll("path")
				.data(majorRoads)
				  .enter()
				  .append("path")
				  .attr("d",path)
				  .attr("stroke","black")
				  .attr("stroke-width","1");
				  
				// load and display the Oxford buildings on top of roads
				d3.json("OX_buildings.geojson", function(error, OXbuildings) {
					if(error){console.log(error);}
					
					//drawing buildings based on geometry from GeoJSON path
					g.append("g")
					.attr("class","buildings")							
					.selectAll("path")
					.data(OXbuildings.features)
					  .enter()
					  .append("path")
					  .attr("d",path)
					  .attr("stroke","transparent")
					  .attr("fill","black");
					  
					// load and display the layered Oxford Ward Information
					d3.json("Jun_6_2013_OX_Boroughs.geojson", function(error, OXzones) {
					
						//sort the wards from highest urban temp to lowest
						OXzones.features.sort(function(a,b) {
							return (b.properties.MEANUrban - a.properties.MEANUrban);
						})
						
						//create an array for determining the colour scale of map/bar graph
						var meanUrban = [];
						for(var i=0;i<OXzones.features.length;i++){
							meanUrban.push(OXzones.features[i].properties.MEANUrban);
						}						
						//apply color function to the domain of mean urban temp data
						color.domain([d3.min(meanUrban),d3.max(meanUrban)]);						  

						//draw the shapes, give them a title, and add some mouseover functionality
						g.append("g")
						.attr("class","wards")								
						.selectAll("path")
						.data(OXzones.features)
						  .enter()
						  .append("path")
						  .attr("d", path)
						  .attr("stroke","black")
						  .attr("stroke-width","2")
						  .attr("opacity","0.75")
						  .attr("fill",function(d){return color(d.properties.MEANUrban);})
						  .on("mouseover", function(d){"<span><u>"+tip.show(d.properties.NAME+"</u></span><br/>Mean Surface Temp (&deg;C): 
								+surfTemp(d.properties.MEANTemp-272.15)+"<br/>Mean Urban Activity Temp (&deg;C): "+urbanTemp(d.properties.MEANUrban))})
						  .on("mouseout", tip.hide);
						//  .html(function(d){return d.properties.NAME+"<br/>Mean Surface Temp: "+d.properties.MEANTemp
						//				+"<br/>Urban Activity Temp: "+d.properties.MEANUrban;});
						//  .on("mouseover", function(d){
						//		divtool.transition()
						//			.duration(200)
						//			.style("opacity", 1);
						//		divtool.html(d.properties.NAME+"<br/>Mean Surface Temp: "+d.properties.MEANTemp
						//			+"<br/>Urban Activity Temp: "+d.properties.MEANUrban)
						//			.style("left",(d3.event.pageX + 10) + "px")
						//			.style("top",(d3.event.pageY - 75) + "px");
						//			})
						// .on("mouseout", function(d){
						//		divtool.transition()
						//			.duration(500)
						//			.style("opacity",0);
						//  }); -->
						//  .on("click", clicked);
						 
						//create the y scale to be linear and to have 0 values at the bottom (height)
						var yScale = d3.scale.linear()
									   .domain([0,d3.max(meanUrban)])
									   .range([heightbar,0]);
						
						//create the x scale to be linear from 0 to 24 (24 wards plus some extra space)
						var xScale = d3.scale.linear()
									   .domain([0,24])
									   .range([0,widthbar]);
						
						//create the y-axis based on the y scale and orient left
						var yAxis = d3.svg.axis()
									  .scale(yScale)
									  .orient("left")
									  .ticks(16);
						
						//create the x-axis based on the x scale and orient bottom
						var xAxis = d3.svg.axis()
									  .scale(xScale)
									  .orient("bottom")
									  .ticks(0);
						
						//create bars(rects) with the width and heights scaled appropriately, and colours
						//applied to the colour scale
						svgbar.selectAll("rect")
							.data(OXzones.features)
							.enter()
							.append("rect")
							.attr("id",function(d){return d.properties.NAME+"_bar";})
							.attr("x", function(d,i){return xScale(i);})
							.attr("y", function(d){return yScale(d.properties.MEANUrban);})
							.attr("width", function(d,i){return (widthbar)/(OXzones.features.length+1);})
							.attr("height", function(d){return heightbar - yScale(d.properties.MEANUrban);})
							.attr("fill", function(d){return color(d.properties.MEANUrban);});							
						
						//append text to each of the bars and orient them vertically for style
						svgbar.selectAll("text")
							.data(OXzones.features)
							.enter()
							.append("text")
							.attr("dx", function(d,i){return xScale(i)-3+(widthbar)/(OXzones.features.length+1);})
							.attr("dy", heightbar-4)
							.attr("transform", function(d,i){return "rotate(-90 "+(xScale(i)-3+(widthbar)/(OXzones.features.length+1))+", "+(heightbar-4)+")";})
							.text(function(d){return d.properties.NAME.slice(0,d.properties.NAME.length-5);})
							.style("font-size",12);
						
						//append y axis and adjust for font sizes, ticks, and label
						svgbar.append("g")
							.attr("class","axis")
							.call(yAxis);
							
						svgbar.append("g")
							.append("text")
							.style("font-size",10)
							.style("text-anchor","middle")
							.attr("dx",-(margin.left/1.5))
							.attr("dy",heightbar/2)							
							.attr("transform","rotate(-90 "+(-(margin.left/1.5))+" "+(heightbar/2)+")")
							.text("Degrees greater than baseline temp");
						
						//opting to leave out an x axis and simply label with "WARDS", translated appropriately
						svgbar.append("g")
							.append("text")
							.attr("transform","translate(0,"+heightbar+")")
							.style("font-weight","bold")
							.style("font-size",16)
							.style("text-anchor","middle")
							.attr("dx",widthbar/2)
							.attr("dy",18)
							.text("WARDS");
							
						svgbar.append("g")
							.append("text")
							.attr("transform","translate(0,"+heightbar+")")
							.style("font-weight","bold")
							.style("font-size",11)
							.style("text-anchor","end")
							.attr("dx",-7)
							.attr("dy",15)							
							.html("(&deg;C)");
							
						svgbar.append("g")
							.append("line")
							.attr("x1",0)
							.attr("y1",heightbar)
							.attr("x2",widthbar)
							.attr("y2",heightbar);
							
			
					});
					
				});
					
			});		
			
			function highlight(id) {
				
			}
			
			function clicked(d) {
			  var x, y, k;

			  if (d && centered !== d) {
				var centroid = path.centroid(d);
				x = centroid[0];
				y = centroid[1];
				k = 2;
				centered = d;
			  } else {
				x = width / 2;
				y = height / 2;
				k = 1;
				centered = null;
			  }

			  g.selectAll("path")
				  .classed("active", centered && function(d) { return d === centered; });

			  g.transition()
				  .duration(750)
				  .attr("transform", "translate(" + width / 2 + "," + height / 2 + ")scale(" + k + ")translate(" + -x + "," + -y + ")");
			}
			
			$(function(){
				$('[data-toggle="popover"]').popover('show');
				console.log($('[data-toggle="popover"]'));
			});
			
		</script>
	</body>
</html>
